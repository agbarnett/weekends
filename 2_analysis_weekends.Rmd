---
title: "Analysis of BMJ submission data over time. Are there more papers and reviews submitted on weekends, holidays and late nights?"
author: "Adrian Barnett"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: word_document
---

```{r setup, include=FALSE}
# basic set up
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE, error=FALSE, comment='', dpi=400)
options(width=1000, scipen = 999) # Wide pages and no scientific numbers
library(R2WinBUGS)
library(season) # for yrfrac and phasecalc
library(lme4) # for glmer
library(broom)
library(stringr)
library(tables)
source('3_tidy_table.R') # for my table tidying
library(pander)
panderOptions('table.emphasize.rownames', FALSE)
panderOptions('keep.trailing.zeros', TRUE)
panderOptions('table.split.table', Inf)
panderOptions('table.split.cells', Inf)
panderOptions('big.mark', ',')
library(dplyr)
library(tidyr)
library(ggplot2)
library(viridis) # for colour schemes
library(gridExtra)
g.theme = theme_bw() + theme(panel.grid.minor = element_blank())
# set up colours
cbPalette = c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
library(RColorBrewer)
top.ten.colours = brewer.pal(n = 10, name = "Paired") # for top ten, from diverging palette

## load the author and reviewer data
load('data/BMJAnalysisReadyAuthors.RData') # authors from 1_bmj_submission_data.R
load('data/BMJAnalysisReadyReviewers.RData') # reviewers from 1_bmj_reviewer_data.R
reviewer = dplyr::select(reviewer, -lon, -lat, -timezoneId, -city, -address) %>% # drop variables not used here
  mutate(type='Reviews')
submission = dplyr::select(submission, -lon, -lat, -timezoneId, -city, -address) %>% # drop variables not used here
  mutate(type='Submission') 
both = bind_rows(reviewer, submission) 
# dates for text below
min.date = min(as.Date(submission$local.date))
max.date = max(as.Date(submission$local.date))
# top ten countries for reviews and submissions (used below)
tab = table(submission$country)
top.ten = names(tab[order(-tab)])[1:10]
tab = table(reviewer$country)
top.ten.reviews = names(tab[order(-tab)])[1:10]
# dates from windows for seasonal analysis (used below)
for.merge = data.frame(window = seq(1,400,1)) %>%
  mutate(date = as.Date('2012-01-02')+(window*7)) # start on Jan 2nd
```

# Modelling approach

All statistical models were fitted using a Bayesian approach and therefore show 95% credible intervals instead of confidence intervals. Credible intervals have the more intuitive interpretation of having a 95% probability of containing the true estimate. We do not use p-values.

When describing changes over time we sometimes use the word "slope".

# Flow diagrams of data

The diagrams below show what journal submissions and reviews were included in the final analyses.

## Diagram for submissions

```{r flow.diagram, fig.width=5, fig.height=6}
source('2_consort_flow.R')
plot.it(sub, header='Submissions', type='rmarkdown')
```

## Diagram for reviews

```{r flow.diagram.reviews, fig.width=5, fig.height=5}
plot.it(rev, header='Reviews', type='rmarkdown')
```

# Summary data on numbers

## Journal numbers

The data are from the journals _BMJ_ and _BMJ Open_.

```{r}
tab = tabular(Heading('Type')*factor(type) ~ (Heading('Journal')*journal + 1)*((n=1) + Percent('row')), data=both)
pander(tab, digits=0)
```

## Journal submissions and reviews over time

```{r plot.over.time, fig.width=9, fig.height=6}
# prepare data for plot
over.time = mutate(both, year = as.numeric(format(local.date, '%Y')), # make month and year
                   month = as.numeric(format(local.date, '%m')),
                   yrmon = year + ((month-1)/12)) %>%
  filter(year < 2019) %>% # remove few papers submitted on 31 December that fall into next time year after timezone adjustment
  group_by(type, journal, yrmon) %>%
  summarise(count = n())
tplot = ggplot(data=over.time, aes(x=yrmon, y=count, col=journal))+
  geom_point()+
  geom_line()+
  scale_color_manual('Journal', values=cbPalette[3:4])+
  xlab('Time')+
  ylab('Monthly number of submissions/reviews')+
  g.theme +
  theme(legend.position = c(0.14,0.8))+
  facet_wrap(~type, scales='free_y')
tplot
```

The plot shows the number of submissions and reviews over time for the two journals.
There has been a clear increase in monthly submissions for _BMJ Open_ with a mirrored increase in review numbers, although on a much larger scale.

This plot is potentially commercial-in-confidence and we should check if _BMJ_ are happy for it to appear in reports.

# Times of day

Here we examine the time-of-day pattern of submissions and reviews by weekdays vs weekends. Using all the countries created plots that were too busy, hence we only show the top ten countries.

The percents are by country and weekday/weekend, so the percents add to 100% for each country on weekdays, and also add to 100% on weekends. 

## Star plots of submissions by hour of day for top ten countries

The star plots show the percentages of submissions made in each country and also split by the weekday and weekend.
The aim is to see what times of the day researchers are most active and if there are noticeable differences between countries.

```{r star.plots, fig.width=13, fig.height=13}
## star plots
# join lines from midnight, see here https://stackoverflow.com/questions/41842249/join-gap-in-polar-line-ggplot-plot

# prepare the data for the plot by calculating percents within country and weekend/weekday
to.plot.star = filter(submission, country %in% top.ten) %>%
  mutate(local.hour = floor(local.hour)) %>%
  group_by(country, local.hour, weekend) %>%
  summarise(count = n()) %>%
  group_by(country, weekend) %>%
  mutate(n = sum(count),
         percent = 100*count/n) %>%
  ungroup() 
# add extra grouping of Europe to help separate lines
to.plot.star = mutate(to.plot.star, 
                      Europe = as.numeric(country %in% c('Denmark','France','Germany','Italy','Netherlands','United Kingdom','Sweden')),
                      Europe = factor(Europe, levels=0:1, labels=c('Non-Europe','Europe')))
# make bridges to join circles
bridges = filter(to.plot.star, local.hour==0) %>%
  mutate(local.hour = 23.99) # just before midnight 
to.plot.star.bridges = bind_rows(to.plot.star, bridges) %>%
  arrange(country, local.hour)
# plot
hour.star = ggplot(data=to.plot.star.bridges, aes(x=local.hour, y=percent, col=country)) +
  geom_path()+
#  geom_point()+
  coord_polar(start=0)+
  scale_x_continuous(limits = c(0,24), minor_breaks = seq(0, 24, 1), breaks=seq(0,24,3))+
  xlab('Hour of day')+
  ylab('Frequency')+
  facet_grid(Europe ~ weekend)+
  ylab('Percent')+
  scale_color_manual('', values=top.ten.colours)+
  g.theme +
  theme(text = element_text(size=20))
hour.star
```

The lines are smoother on weekdays because of the larger sample size.

### Line plots of submission times

This plot shows the same information as the star plot, but using a linear time axis.

```{r non-star, fig.width=13, fig.height=13}
hour.nonstar = ggplot(data=to.plot.star, aes(x=local.hour, y=percent, col=country)) +
  geom_line(size=1.1)+
  scale_x_continuous(limits = c(0,24), minor_breaks = seq(0, 24, 1), breaks=seq(0,24,6))+
  xlab('Hour of day')+
  ylab('Frequency')+
  facet_grid(Europe~weekend)+
  ylab('Percent')+
  scale_color_manual('', values=top.ten.colours)+
  g.theme +
  theme(text = element_text(size=20))
hour.nonstar
```

As well as the obvious diurnal pattern, there does appear to be a slight increase in submissions just before midnight.

## Star plots of reviews by hour of day for top ten countries

The star plots show the percentages of reviews made in each country and also split by the weekday and weekend.

```{r star.plots.reviews, fig.width=12, fig.height=12}
## star plots
# prepare the data for the plot by calculating percents within country and weekend/weekday
to.plot.star.review = filter(reviewer, country %in% top.ten.reviews) %>%
  mutate(local.hour = floor(local.hour)) %>% # re-format Yes/No categories, but just for these plots
  group_by(country, local.hour, weekend) %>%
  summarise(count = n()) %>%
  group_by(country, weekend) %>%
  mutate(n = sum(count),
         percent = 100*count/n) %>%
  ungroup() 
# add extra grouping of Europe to help separate lines
to.plot.star.review = mutate(to.plot.star.review, 
                      Europe = as.numeric(country %in% c('Denmark','France','Germany','Italy','Netherlands','United Kingdom','Sweden')),
                      Europe = factor(Europe, levels=0:1, labels=c('Non-Europe','Europe')))
# make bridges to join circles
bridges = filter(to.plot.star.review, local.hour==0) %>%
  mutate(local.hour = 23.99) # just before midnight 
to.plot.star.review.bridges = bind_rows(to.plot.star.review, bridges) %>%
  arrange(country, local.hour)
# plot
hour.star = ggplot(data=to.plot.star.review.bridges, aes(x=local.hour, y=percent, col=country)) +
  geom_path()+
#  geom_point()+
  coord_polar(start=0)+
  scale_x_continuous(limits = c(0,24), minor_breaks = seq(0, 24, 1), breaks=seq(0,24,3))+
  xlab('Hour of day')+
  ylab('Frequency')+
  facet_grid(Europe ~ weekend)+
  ylab('Percent')+
  scale_color_manual('', values=top.ten.colours)+
  g.theme +
  theme(text = element_text(size=20))
hour.star
```

### Line plots of review times

This plot shows the same information as the star plot, but using a linear time axis.

```{r non-star.review, fig.width=12, fig.height=12}
hour.nonstar = ggplot(data=to.plot.star.review, aes(x=local.hour, y=percent, col=country)) +
  geom_line(size=1.1)+
  scale_x_continuous(limits = c(0,24), minor_breaks = seq(0, 24, 1), breaks=seq(0,24,6))+
  xlab('Hour of day')+
  ylab('Frequency')+
  facet_grid(Europe~weekend)+
  ylab('Percent')+
  scale_color_manual('', values=top.ten.colours)+
  g.theme +
  theme(text = element_text(size=20))
hour.nonstar
```

As well as the obvious diurnal pattern, there may be small lunch time peaks in some countries.

## Line plots of the ratio of submissions to reviews by hour of day for the top ten countries

The plot below shows the ratio of the percentage of submissions to reviews, so it combines the data from the above line plots. The aim is to show times when relatively more submissions are received than reviews. The plot uses percents and not absolute numbers, so it looks at the relative difference in activity. There are far more reviews than submissions, so if we used absolute numbers any relative change would be lost.

```{r star.plots.ratio, fig.width=12, fig.height=7}
## make ratio of star plots,
to.plot.star = rename(to.plot.star, 'submission' = 'percent') %>%
  dplyr::select(-count, -n)
to.plot.star.review = rename(to.plot.star.review, 'review' = 'percent') %>%
  dplyr::select(-count, -n)
ratio = left_join(to.plot.star, to.plot.star.review, by=c('country','local.hour','Europe','weekend')) %>%
  mutate(ratio = submission / review) 
# plot
ratio.plot = ggplot(data=ratio, aes(x=local.hour, y=ratio, col=country)) +
  geom_line(size=1.05)+
  geom_hline(yintercept=1, lty=2)+
  scale_x_continuous(limits = c(0,24), minor_breaks = seq(0, 24, 1), breaks=seq(0,24,3))+
  xlab('Hour of day')+
  ylab('Frequency')+
  facet_grid(Europe~weekend)+
  ylab('Ratio')+
  annotate('text', x=0, y=1.9, label='More submissions', hjust=0)+
  annotate('text', x=0, y=0.1, label='More reviews', hjust=0)+
  scale_color_manual('', values=top.ten.colours)+
  coord_cartesian(ylim=c(0,2))+ # truncate because of few extremes in early mornings on weekends
  g.theme +
  theme(text = element_text(size=20))
ratio.plot
```

The percent axis has been truncated as there were a few very large estimates in early mornings on weekends, but these had small sample sizes.

# Weekends

In this section we tabulate, plot and model the data on weekend submissions and reviews.

## Submissions

The table shows the overall frequency of submissions on weekdays and weekends in the top ten submitting countries.

```{r table.weekends}
to.table = filter(submission, country %in% top.ten) %>%
  mutate(country = factor(as.character(country))) # remove empty categories
tab = tabular(Heading('Country')*country + 1 ~  Heading('')*weekend*( (n=1) + Heading('%')*Percent('row')*Format(digits=3)), data=to.table)
pander(tab)
```

## Reviews

The table shows the overall frequency of reviews on weekdays and weekends in the top ten reviewing countries.

```{r table.weekends.reviews}
to.table = filter(reviewer, country %in% top.ten.reviews) %>%
  mutate(country = factor(as.character(country))) # remove empty categories
tab = tabular(Heading('Country')*country + 1 ~  Heading('')*weekend*( (n=1) + Heading('%')*Percent('row')*Format(digits=3)), data=to.table)
pander(tab)
```

## Plots of weekdays by year

The aim is to look for a trend over time in the percent of weekend submissions and reviews.
The plots show the annual numbers of submissions and reviews by day of the week from 2012 to 2018.

### Submissions

```{r plot.submissions, fig.width=11, fig.height=7}
# combine into weekends vs weekdays
wdays = c('Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday')
wdays2 = c('Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday')
to.plot = mutate(submission, 
                 year = as.numeric(format(local.date, '%Y')), # make year and weekday
         weekday = as.numeric(format(local.date, '%w')),
         weekday = factor(weekday, levels=0:6, labels=wdays),
         weekday = ordered(weekday, levels=wdays2)) %>% # order with Monday first
  filter(year < 2019) %>% # remove papers from 2019 for this plot so that we have full years
  group_by(year, journal, weekday) %>% # stratify by year and journal
  summarise(count = n()) %>%
  group_by(year, journal) %>%
  mutate(sum = sum(count), # counts by year and journal
         percent = 100*count/sum) %>%
  ungroup()
# plot
wplot = ggplot(data=to.plot, aes(x=year, y=percent, col=weekday))+
  geom_line(lwd=1.1)+
  scale_color_manual(NULL, values=cbPalette[1:7])+
  ylab('Submission percentages')+
  xlab('Year')+
  g.theme + 
  theme(legend.position = 'right', legend.direction = 'vertical', text=element_text(size=16))+
  facet_wrap(~journal)
wplot
```

### Reviews

```{r plot.reviews, fig.width=11, fig.height=7}
to.plot = mutate(reviewer, year = as.numeric(format(local.date, '%Y')), # make year and weekday
         weekday = as.numeric(format(local.date, '%w')),
         weekday = factor(weekday, levels=0:6, labels=wdays),
         weekday = ordered(weekday, levels=wdays2)) %>% # order with Monday first
  filter(year < 2019) %>% # remove papers from 2019 for this plot so that we have full years
  group_by(year, journal, weekday) %>% # stratify by year and journal
  summarise(count = n()) %>%
  group_by(year, journal) %>%
  mutate(sum = sum(count), # counts by year and journal
         percent = 100*count/sum) %>%
  ungroup()
# plot
wplot = ggplot(data=to.plot, aes(x=year, y=percent, col=weekday))+
  geom_line(lwd=1.1)+
  scale_color_manual(NULL, values=cbPalette[1:7])+
  ylab('Review percentages')+
  xlab('Year')+
  g.theme + 
  theme(legend.position = 'right', legend.direction = 'vertical', text=element_text(size=16))+
  facet_wrap(~journal)
wplot
```

The most common day for reviews was Monday and the least common day was Saturday.

## Plot of weekend percents by week-to-week results

The plots below aim to examine the trend over time in weekend submissions and reviews. They show the Weekly percentage of submitted papers and reviewers on the weekend. The blue line is a non-linear smooth using a loess with a span of 0.75.

### Submissions

```{r week2week.submissions, fig.width=12, fig.height=7}
# first get axis labels in years by window numbers
axis.labels = mutate(submission, 
                     year=format(local.date, '%Y'),
                     month=format(local.date, '%m'),
                     day=format(local.date, '%d')) %>%
  filter(month=='01', day=='02') %>% # use Jan 2nd because Jan 1st was excluded as it was not a full week
  dplyr::select(year, window) %>%
  unique()
# plot weekends by week-to-week
for.plot = arrange(submission, local.date) %>%
  group_by(window, journal, weekend) %>%
  summarise(count = n()) %>%
  tidyr::spread(key=weekend, value=count) %>% # put weekends and weekdays on same row
  mutate(Weekday = ifelse(is.na(Weekday), 0, Weekday), # replace missing with zero
         Weekend = ifelse(is.na(Weekend), 0, Weekend),
         denom = Weekday + Weekend,
         percent = 100*Weekend/denom)
tplot = ggplot(data=for.plot, aes(x=window, y=percent))+
  geom_line()+
  geom_smooth(col='skyblue', se = FALSE, method='loess', span=0.75)+
  g.theme+
  scale_x_continuous(breaks=axis.labels$window, labels=axis.labels$year)+
  ylab('Weekly percent')+
  xlab('Time')+
  facet_wrap(~journal)+
  theme(text = element_text(size=16))
tplot
```

The estimated trends shows a small increase in weekend submissions over time.

### Reviews

```{r week2week.reviewers, fig.width=12, fig.height=7}
# plot weekends by week-to-week
for.plot = arrange(reviewer, local.date) %>%
  group_by(window, journal, weekend) %>%
  summarise(count = n()) %>%
  tidyr::spread(key=weekend, value=count) %>% # put weekends and weekdays on same row
  mutate(Weekday = ifelse(is.na(Weekday), 0, Weekday), # replace missing with zero
         Weekend = ifelse(is.na(Weekend), 0, Weekend),
         denom = Weekday + Weekend,
         percent = 100*Weekend/denom)
tplot = ggplot(data=for.plot, aes(x=window, y=percent))+
  geom_line()+
  geom_smooth(col='skyblue', se = FALSE, method='loess', span=0.75)+
  g.theme+
  scale_x_continuous(breaks=axis.labels$window, labels=axis.labels$year)+
  ylab('Weekly percent')+
  xlab('Time')+
  facet_wrap(~journal)+
  theme(text = element_text(size=16))
tplot
```

There does appear to be a small increase over time in weekend reviews, especially for BMJ Open.

# Statistical models - weekend submissions

Here we examine a relative increase in weekend submissions over time using a binomial model.
We run separate models in each of the two journals.
We used a country-specific intercept for each country to control for differences between countries in the probability of submitting on the weekend.
We plot the country-specific intercepts to show the differences between countries. We exclude countries with small numbers from the plots.

In terms of the change over time in weekend submissions, we use two models.
The simpler model assumes the change is the same in every country.
The more complex model allows a country-specific change over time.
We plot the country-specific changes.

We examine a seasonal pattern in submissions using a sinusoidal model with an annual cycle. We allow the seasonal pattern to vary by country. We plot the overall season pattern and the phase and amplitude in each country. The phase is the timing of the seasonal peak and the amplitude is its height.

We compare the fit of the models using the deviance information criterion.

## BMJ weekend submissions

This section examines journal submissions on the weekend to the BMJ.

### Best fitting model

First we examine the deviance information criterion (DIC) to find the best model

```{r best.bmj.weekend.submissions}
DIC = DIC.best = NULL
which.outcome = 'weekend'
which.data.text = 'submissions' # data with windows
which.data.text.update = 'submissions.weekend'
which.data = get(which.data.text.update)
which.journal  = 'BMJ'
for (type in c('slope','intercept')){
  for (season in c(TRUE, FALSE)){
    source('99_jags_filename.R') # create filenames for data, chains and results
    l = length(dir('Z:/weekend', pattern=jags.filename.results)) # flag that results exist
    load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R on HPC
    DIC = bind_rows(DIC, dic.frame)
  }
}
DIC = mutate(DIC, Difference = DIC - min(DIC)) 
to.table = dplyr::select(DIC, -journal, -outcome, -data) %>% # information already in title
  arrange(DIC)
pander(to.table, digits=0, style='simple')
# load the results for the best model and store best DIC for later use
best = filter(DIC, Difference==0) 
DIC.best = bind_rows(DIC.best, best)
type = best$model
season = ifelse(best$season=='Season', TRUE, FALSE)
source('99_jags_filename.R') # create filenames for data, chains and results
load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R on HPC
```

The best model (smallest DIC) has both a country-specific slope and a seasonal pattern. Hence we show the results for this model below.

### Table of parameter estimates for best model for weekend submissions to BMJ

```{r best.bmj.weekend.submission.results}
# output table
to.table = tidy.table(ests)
pander(to.table, digits=3)
```

The intercept is the overall average and the change is the annual change in probability. Both are on a logit scale because we used a binomial model.
The two estimated probabilities are for 2012 and 2013 and are used to show the annual difference in weekend submissions. The difference is the absolute increase in probability per year. The ratio is the relative change in probability per year.

There was little change over time in the probability of submitting on the weekend.

### Plot of country-specific intercepts and 95% credible intervals for weekend submissions to BMJ

The plot below shows the estimated weekend probability in each country. 
The aim is to look for interesting differences between countries in the probability of submitting papers on the weekend.
The 95% credible intervals are wider for countries with fewer submissions.
The countries are ordered by their mean probability, making it easier to spot patterns which countries have similar means.

```{r plot.intercepts.bmj.submissions}
source('2_plot_intercepts.R')
iplot
# export to journal for best model for weekend submissions (example forest plot)
jpeg('figures/BarnettFig3.jpg', width=5.5, height=4.25, units='in', res=400, quality = 100) # bigger size for BMJ
print(iplot)
invisible(dev.off())
```

There are large differences between countries in the probability of submitting on the weekend. The lowest average probability is in India and the highest average in China. In China the probability is very high and almost equivalent to an equal probability on any day of the week as 2 days out of 7 is a probability of 0.29.

### Plot of country-specific slopes and 95% credible intervals for weekend submissions to BMJ

```{r plot.slopes.bmj.submissions}
source('2_plot_slopes.R')
splot
```

The dotted vertical line is the average change over time, which is close to zero indicating no change across all countries. Japan has the largest average increase over time in weekend submissions and Austria the smallest average.

### Plot of seasonal estimates for weekend submissions to BMJ

The plots are: i) the average sinusoidal seasonal pattern, ii) the country-specific seasonal pattern using a circular plot. The position of the dot shows the phase, which is the location of the peak. January is at 12 o'clock on the circle and July at 6 o'clock. Dots close to the centre have only a weak seasonal pattern, whereas those further towards the edge have a stronger seasonal pattern (amplitude).

```{r plot.season.bmj.weekend.submissions, fig.width=13, fig.height=6.5}
source('2_plot_season.R')
grid.arrange(mplot, seasonplot, nrow = 1)
```

The seasonal pattern in submissions peaks in January with an odds ratio of 1.1. The country-specific estimates show a number of countries close to the centre, meaning they have little seasonal pattern. The strongest seasonal patterns are in Israel, Iran, Finland, New Zealand, and Norway.

## BMJ Open weekend submissions

This section examines journal submissions on the weekend to BMJ Open.

### Best fitting model

First we examine the deviance information criterion (DIC) to find the best model

```{r best.bmjopen.weekend.submissions}
DIC = NULL
which.outcome = 'weekend'
which.data.text = 'submissions' # data with windows
which.data.text.update = 'submissions.weekend' #
which.data = get(which.data.text.update)
which.journal  = 'BMJ Open'
for (type in c('slope','intercept')){
  for (season in c(TRUE, FALSE)){
    source('99_jags_filename.R') # create filenames for data, chains and results
    l = length(dir('Z:/weekend', pattern=jags.filename.results)) # flag that results exist
    load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R on HPC
    DIC = bind_rows(DIC, dic.frame)
  }
}
DIC = mutate(DIC, Difference = DIC - min(DIC)) 
to.table = dplyr::select(DIC, -journal, -outcome, -data) %>% # information already in title
  arrange(DIC)
pander(to.table, digits=0, style='simple')
# load the results for the best model
best = filter(DIC, Difference==0)
DIC.best = bind_rows(DIC.best, best)
type = best$model
season = ifelse(best$season=='Season', TRUE, FALSE)
source('99_jags_filename.R') # create filenames for data, chains and results
load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R on HPC
```

The best model has a country-specific slope and season, hence we show the results for this model below.

### Table of parameter estimates for best model for weekend submissions to BMJ Open

```{r best.bmjopen.weekend.submission.results}
# output table
to.table = tidy.table(ests)
pander(to.table, digits=3)
```

There was almost no difference in the overall probability of weekend submissions over time.

### Plot of country-specific intercepts and 95% credible intervals for weekend submissions to BMJ Open

```{r plot.intercepts.bmjopen.weekend.submissions}
source('2_plot_intercepts.R')
iplot
```

There is a very large difference between countries in the probability of weekend submissions to BMJ Open. China and Taiwan both also have relatively high probabilities of weekend submissions.

### Plot of country-specific slopes and 95% credible intervals for weekend submissions to BMJ Open

```{r plot.slopes.bmjopen.weekend.submissions}
source('2_plot_slopes.R')
splot
```

The dotted vertical line is the mean which is close to zero meaning no change across all countries. Malaysia had the largest mean increase in weekend submissions over time, but the uncertainty around this mean was large. 

# Statistical models - weekend reviews

In this section we examine reviews on the weekend.

## BMJ weekend reviews

This section examines journal reviews on the weekend to the BMJ.

### Best fitting model for BMJ weekend reviews

First we examine the deviance information criterion (DIC) to find the best model

```{r best.bmj.weekend.reviews}
DIC = NULL
which.outcome = 'weekend'
which.data.text = 'reviews' # data with windows
which.data.text.update = 'reviews.weekend'
which.data = get(which.data.text.update)
which.journal  = 'BMJ'
for (type in c('slope','intercept')){
  for (season in c(TRUE, FALSE)){
    source('99_jags_filename.R') # create filenames for data, chains and results
    l = length(dir('Z:/weekend', pattern=jags.filename.results)) # flag that results exist
    load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R on HPC
    DIC = bind_rows(DIC, dic.frame)
  }
}
DIC = mutate(DIC, Difference = DIC - min(DIC)) 
to.table = dplyr::select(DIC, -journal, -outcome, -data) %>% # information already in title
  arrange(DIC)
pander(to.table, digits=0, style='simple')
# load the results for the best model
best = filter(DIC, Difference==0)
DIC.best = bind_rows(DIC.best, best) # store best DIC for later use
type = best$model
season = ifelse(best$season=='Season', TRUE, FALSE)
source('99_jags_filename.R') # create filenames for data, chains and results
load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R on HPC
```

### Table of parameter estimates for best model for weekend reviews to BMJ

```{r best.bmj.weekend.reviews.results}
# output table
to.table = tidy.table(ests)
pander(to.table, digits=3)
```

There was no change in the probability of weekend reviews over time.

### Plot of country-specific intercepts and 95% credible intervals for weekend reviews to BMJ

```{r plot.intercepts.bmj.weekends.reviews}
source('2_plot_intercepts.R')
iplot
```

Finland had the lowest probability of weekend reviews and Austria the highest.

### Plot of country-specific slopes and 95% credible intervals for weekend reviews to BMJ

```{r plot.slopes.bmj.weekends.reviews}
source('2_plot_slopes.R')
splot
```

There was a relatively small variation in slopes between countries.

### Plot of seasonal estimates for weekend reviews to BMJ

```{r plot.season.bmj.weekend.reviews, fig.width=13, fig.height=6.5}
source('2_plot_season.R')
grid.arrange(mplot, seasonplot, nrow = 1)
```

The seasonal pattern was mixed. A relatively large number of countries peaked in December and January. Sweden was a notable outlier with a peak in late May.

## BMJ Open weekend reviews

This section examines journal reviews on the weekend to the BMJ Open.

### Best fitting model for BMJ Open weekend reviews

First we examine the deviance information criterion (DIC) to find the best model

```{r best.bmjopen.weekend.reviews}
DIC = NULL
which.outcome = 'weekend'
which.data.text = 'reviews' # data with windows
which.data.text.update = 'reviews.weekend'
which.data = get(which.data.text.update)
which.journal  = 'BMJ Open'
for (type in c('slope','intercept')){
  for (season in c(TRUE, FALSE)){
    source('99_jags_filename.R') # create filenames for data, chains and results
    l = length(dir('Z:/weekend', pattern=jags.filename.results)) # flag that results exist
    load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R on HPC
    DIC = bind_rows(DIC, dic.frame)
  }
}
DIC = mutate(DIC, Difference = DIC - min(DIC)) 
to.table = dplyr::select(DIC, -journal, -outcome, -data) %>% # information already in title
  arrange(DIC)
pander(to.table, digits=0, style='simple')
# load the results for the best model
best = filter(DIC, Difference==0)
if(any(DIC$Difference>0 & DIC$Difference<1)){
  best = filter(DIC, Difference>0, Difference<1) # shift to second best because hardly any difference
}
DIC.best = bind_rows(DIC.best, best) # store best DIC for later use
type = best$model
season = ifelse(best$season=='Season', TRUE, FALSE)
source('99_jags_filename.R') # create filenames for data, chains and results
load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R on HPC
```

There is almost a tie for the best model between a seasonal model with a country-specific slope and common slope. We choose the common slope because this is the simpler model.

### Table of parameter estimates for best model for weekend reviews to BMJ Open

```{r best.bmjopen.weekend.reviews.results}
# output table
to.table = tidy.table(ests)
pander(to.table, digits=3)
```

There was a very small increase in weekend reviews over time.

### Plot of country-specific intercepts and 95% credible intervals for weekend reviews to BMJ Open

```{r plot.intercepts.bmjopen.weekends.reviews}
source('2_plot_intercepts.R')
iplot
```

There is a large variability between countries in the probability of weekend reviews. The highest probability is in Israel and the lowest in Ireland.

### Plot of seasonal estimates for weekend reviews to BMJ Open

```{r plot.season.bmjopen.weekend.reviews, fig.width=13, fig.height=6.5}
source('2_plot_season.R')
grid.arrange(mplot, seasonplot, nrow = 1)
```

There is a relatively weak season pattern of a peak in odds of over 1.02 in August. The strongest seasonal patterns are in Norway, Japan and South Korea.


# Holidays

In this section we examine the probability of submissions and reviews on national holidays. We only examine weeks that included a holiday and model the probability of a submission or review on a holiday compared with the other days in that week.

## Submissions to BMJ

```{r bmj.holiday.submission.results}
# write out filename
jags.filename.results = 'JAGS.holiday.submission.BMJ.intercept.NoSeason.results.RData'
load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R 
# output table
to.table = tidy.table(ests)
pander(to.table, digits=3)
```

### Plot of country-specific intercepts and 95% credible intervals for holiday submissions to BMJ

```{r plot.intercepts.bmj.submissions.holidays}
source('2_plot_intercepts_holiday.R')
iplot
```

## Submissions to BMJ Open

```{r bmjopen.holiday.submission.results}
# write out filename
jags.filename.results = 'JAGS.holiday.submission.BMJ Open.intercept.NoSeason.results.RData'
load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R 
# output table
to.table = tidy.table(ests)
pander(to.table, digits=3)
```

### Plot of country-specific intercepts and 95% credible intervals for holiday submissions to BMJ Open

```{r plot.intercepts.bmjopen.submissions.holidays}
source('2_plot_intercepts_holiday.R')
iplot
```

## Reviews to BMJ

```{r bmj.holiday.reviews.results}
# write out filename
jags.filename.results = 'JAGS.holiday.reviewer.BMJ.intercept.NoSeason.results.RData'
load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R 
# output table
to.table = tidy.table(ests)
pander(to.table, digits=3)
```

### Plot of country-specific intercepts and 95% credible intervals for holiday reviews to BMJ

```{r plot.intercepts.bmj.reviews.holidays}
source('2_plot_intercepts_holiday.R')
iplot
```

## Reviews to BMJ Open

```{r bmjopen.holiday.reviews.results}
# write out filename
jags.filename.results = 'JAGS.holiday.reviewer.BMJ Open.intercept.NoSeason.results.RData'
load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R 
# output table
to.table = tidy.table(ests)
pander(to.table, digits=3)
```

### Plot of country-specific intercepts and 95% credible intervals for holiday reviews to BMJ Open

```{r plot.intercepts.bmjopen.reviews.holidays}
source('2_plot_intercepts_holiday.R')
iplot
```

# Late nights and early mornings

In this section we examine late nights and early mornings. We previously used a simple dichotomous definition of late nights and early mornings versus working hours, which was after 6pm or before 7am. Here we instead examine the results over the 24-hour clock and examine differences between countries.

We use a Poisson model for submissions and reviews:

$n_{h,j} \sim Poisson(\mu_{h,j}), \qquad h = 1\ldots 24, \, j=1,\ldots,C$,

where $n_{h,j}$ is the number of reviews or submissions in hour $h$ in country $j$ and there are $C$ countries in total. The regression equation is:

$\log(\mu_{h,j}) = \log(N_j) + \alpha + (\beta_h - \overline{\beta}) + \gamma_{j,1}\cos[2\pi (h-1)/24] + \gamma_{j,2}\sin[2\pi (h-1)/24]$,

where $N_j$ is an offset as it is the total number of reviews or submissions in country $j$ and $\alpha$ is the overall intercept with non-informative prior $\alpha \sim N(0, 10^4)$. The $\beta$'s are the average effect in each hour defined as:

$\beta_h \sim N(0,\tau_\beta^{-1}), \qquad h=1,\ldots, 24,$

and we subtract the overall mean $\beta$ in the regression equation so that these estimates are the difference from the average. The prior for the inverse variance uses a Gamma distribution $\tau_\beta \sim Ga(1, 1)$. 

The cosine and sine functions combine to create a smooth sinusoidal wave for each country that has one peak at any time during the 24-hour clock. To ensure that the sinusoid was centred around the average, we subtracted the overall mean using:

$\gamma_{j,k} = \gamma^*_{j,k} - \overline{\gamma}_k$,

with non-informative priors for the $\gamma^*$'s:

$\gamma^*_{j,k} \sim N(0, 10^4), \qquad j = 1,\ldots,C,\, k=1,2$.

This meant that for a country with $\gamma_{j,1}=\gamma_{j,2}=0$, that country had no difference in submission or reviews times over the 24-hour clock from the overall average. 

```{r, include=FALSE}
# Needed for statement below about chains
load('data/bugs.results.country.difference.Submissions.RData') # from 2_country_difference_from_average.R
# make credible intervals for amplitude
source('2_amplitude_CIs.R')
# calculate R-squared
source('2_r_square.R')
```

We used `r num.chains` chains each with `r MCMC` estimates thinned by `r thin`.

## Peak time for submissions by country

The scatter plot below shows the timing and size of the peak in reviews for each country.

```{r reconstruct.country.amplitude.phase.submissions}
# calculate the phase and amplitude of the sinusoid
cosine = data.frame(bugs.results$summary[grep('^cosine.c', row.names(bugs.results$summary)), c(1,3,7)]); names(cosine)=c('mean','lower','upper')
cosine = mutate(cosine, country.num = 1:n(),
                type = 'cosine')
sine = data.frame(bugs.results$summary[grep('^sine.c', row.names(bugs.results$summary)), c(1,3,7)]); names(sine)=c('mean','lower','upper')
sine = mutate(sine, country.num = 1:n(),
              type = 'sine')
# check for statistical significance - no longer used, but kept code
stat.sig = bind_rows(sine, cosine) %>%
  mutate(country = country.list[country.num],
         sig = lower > 0 | upper < 0) %>%
  dplyr::select(country.num, country, type, sig) %>%
  tidyr::spread(type, sig) %>%
  mutate(stat.sig = cosine + sine > 0)
both.results.submissions = bind_rows(sine, cosine) %>%
  dplyr::select(-lower, -upper) %>%
  tidyr::spread(type, mean) %>%
  mutate(
    country = country.list[country.num],
    country = ifelse(country=='United States', 'USA', country), # to reduce clutter
    country = ifelse(country=='United Kingdom', 'UK', country), # to reduce clutter
    phase = NA, # did not work in mutate
    amp = sqrt(cosine^2 +sine^2))
both.results.submissions = left_join(both.results.submissions, dplyr::select(stat.sig, country.num, stat.sig), by="country.num") %>%
  left_join(amp.stats, by="country.num") # add credible intervals for amplitude
# filter on significance or not?
# %>% filter(stat.sig == TRUE) # just the statistically significant results
for (k in 1:nrow(both.results.submissions)){
  both.results.submissions$phase[k] = phasecalc(both.results.submissions$cosine[k], both.results.submissions$sine[k])
}
both.results.submissions = mutate(both.results.submissions, phase.time = 24*phase/(2*pi)) # convert phase to hours
# scatter plot
splot = ggplot(data=both.results.submissions, aes(x=phase.time, y=exp(amp), label=country))+
  geom_point(col='skyblue')+
  ggrepel::geom_label_repel(label.size=NA, fill='transparent')+ # avoid overlap; no border
  scale_x_continuous(breaks=seq(0,24,6), limits=c(0,24), labels=c('0am','6am','12pm','6pm',''))+
  xlab('Peak time (24-hour clock)')+
  ylab('Probability ratio')+
  scale_y_continuous(limits=c(1, NA))+ # start at 1
  theme_bw()
splot
```

The R-squared of the model is `r round(rsq)`%.

### Table of peak time and height for submissions

The table below gives the same information as the above plot. The rows are ordered by the probability ratio.

```{r table.phase.amplitude.submissions}
to.table = dplyr::select(both.results.submissions, country, phase.time, meana, lowera, uppera) %>%
  arrange(-meana) %>%
  mutate(`95% CI` = paste(sprintf(lowera, fmt='%4.2f'), ', ', sprintf(uppera, fmt='%4.2f'), sep=''),
    phase.time = floor(phase.time), # hour
         phase.plus = phase.time + 1,
         phase.plus = ifelse(phase.plus==24, 0, phase.plus),
    phase.time = paste('[', floor(phase.time), '-', phase.plus, ')', sep=''),
         meana = sprintf(meana, fmt='%4.2f')) %>% # transform to ratio
  rename('Probability ratio' = 'meana',
         'Peak hour'='phase.time') %>%
  dplyr::select(-phase.plus, -lowera, -uppera)
pander(to.table, style='simple')
```

Submissions from China were 86% higher than the average during the hours of midnight to just before 1am. Germany had the smallest increase in submissions at just 7% higher than the average from 10am to just before 11am.

## Difference in journal submissions (late nights and early mornings)

The plot below shows the predicted means for each hour of the day for the two journals. This combines the overall estimates for each hour with the smooth sinusoid used to model the differences between the two journals.

```{r sinusoid.journal.outofhours.submission}
# reconstruct country means ##
oframe = data.frame(hour=0:23, country='Overall', country.num=0, est = bugs.results$median$intercept + bugs.results$median$beta, stringsAsFactors = FALSE)
# now get the journal specific curve
journal.smooth = bugs.results$median$cosine.j*cos(0:23*2*pi/24) +
  bugs.results$median$sine.j*sin(0:23*2*pi/24)
bmj.open.ests = mutate(oframe, journal = 'BMJ Open')
bmj.ests = mutate(oframe, journal = 'BMJ', est = est + journal.smooth)
to.plot = bind_rows(bmj.open.ests, bmj.ests)
ggplot(data=to.plot, aes(x=hour+0.5, y=exp(est), col=factor(journal)))+
  geom_line(size=1.1)+
  scale_x_continuous(breaks=c(0,6,12,18,24), minor_breaks = 0:24)+
  xlab('Hour')+
  ylab('Probability')+
  scale_color_manual(NULL, values = cbPalette[3:4])+
  theme_bw()+
  theme(legend.position = c(0.2,0.8),
        panel.grid.minor.y = element_blank())
```

As the plot shows, there was little difference in the timing of reviews between the two journals. There were slightly more reviews for the BMJ Open around midday.

## Peak time for reviews by country

```{r reconstruct.country.amplitude.phase.reviews}
# get the results and calculate the phase and amplitude of the sinusoid
load('data/bugs.results.country.difference.Reviews.RData') # from 2_country_difference_from_average.R
# make credible intervals for amplitude
source('2_amplitude_CIs.R')
# calculate R-squared
source('2_r_square.R')
# 
cosine = data.frame(bugs.results$summary[grep('^cosine.c', row.names(bugs.results$summary)), c(1,3,7)]); names(cosine)=c('mean','lower','upper')
cosine = mutate(cosine, country.num = 1:n(),
                type = 'cosine')
sine = data.frame(bugs.results$summary[grep('^sine.c', row.names(bugs.results$summary)), c(1,3,7)]); names(sine)=c('mean','lower','upper')
sine = mutate(sine, country.num = 1:n(),
              type = 'sine')
# check for statistical significance
stat.sig = bind_rows(sine, cosine) %>%
  mutate(country = country.list[country.num],
         sig = lower>0 | upper < 0) %>%
  dplyr::select(country.num, country, type, sig) %>%
  tidyr::spread(type, sig) %>%
  mutate(stat.sig = cosine + sine > 0)
both.results.reviews = bind_rows(sine, cosine) %>%
  dplyr::select(-lower, -upper) %>%
  tidyr::spread(type, mean) %>%
  mutate(
    country = country.list[country.num],
    country = ifelse(country=='United States', 'USA', country), # to reduce clutter
    country = ifelse(country=='United Kingdom', 'UK', country), # to reduce clutter
    phase = NA, # did not work in mutate
    amp = sqrt(cosine^2 +sine^2))
both.results.reviews = left_join(both.results.reviews, dplyr::select(stat.sig, country.num, stat.sig), by="country.num") %>%
  left_join(amp.stats, by="country.num") # add credible intervals for amplitude
# option to filter on statistical significance
#%>% filter(stat.sig == TRUE) # just the statistically significant results
for (k in 1:nrow(both.results.reviews)){
  both.results.reviews$phase[k] = phasecalc(both.results.reviews$cosine[k], both.results.reviews$sine[k])
}
both.results.reviews = mutate(both.results.reviews, phase.time = 24*phase/(2*pi)) # convert phase to hours
# scatter plot
splot = ggplot(data=both.results.reviews, aes(x=phase.time, y=meana, label=country))+
  geom_point(col='skyblue')+
  ggrepel::geom_label_repel(label.size=NA, fill='transparent')+ # avoid overlap; no border
  scale_x_continuous(breaks=seq(0,24,6), limits=c(0,24), labels=c('0am','6am','12pm','6pm',''))+
  xlab('Peak time (24-hour clock)')+
  ylab('Probability ratio')+
  scale_y_continuous(limits=c(1, NA))+ # start at 1
  theme_bw()
splot
```

The R-squared of the model is `r round(rsq)`%.

### Table of peak time and height for reviews

The table below gives the same information as the above plot. The rows are ordered by the probability ratio.

```{r table.phase.amplitude.reviews}
to.table = dplyr::select(both.results.reviews, country, phase.time, meana, lowera, uppera) %>%
  arrange(-meana) %>%
  mutate(`95% CI` = paste(sprintf(lowera, fmt='%4.2f'), ', ', sprintf(uppera, fmt='%4.2f'), sep=''),
    phase.time = floor(phase.time), # hour
         phase.plus = phase.time + 1,
         phase.plus = ifelse(phase.plus==24, 0, phase.plus),
    phase.time = paste('[', floor(phase.time), '-', phase.plus, ')', sep=''),
         meana = sprintf(meana, fmt='%4.2f')) %>% # transform to ratio
  rename('Probability ratio' = 'meana',
         'Peak hour'='phase.time') %>%
  dplyr::select(-phase.plus, -lowera, -uppera)
pander(to.table, style='simple')
```

China has the highest increase in reviews, with an average 57% higher during the hours of midnight to just before 1am. Switzerland had the smallest increase in reviews at just 9% higher than the average from 11am to just before midday. 

```{r, journal.plot.reviews, include=FALSE}
# combine two scatter plots
both.results.submissions = mutate(both.results.submissions, panel= 1)
both.results.reviews = mutate(both.results.reviews, panel = 2)
to.plot = bind_rows(both.results.submissions, both.results.reviews) %>%
  mutate(panel = factor(panel, levels=1:2, labels=c('Submissions','Peer reviews')))
# scatter plot
splot = ggplot(data=to.plot, aes(x=phase.time, y=exp(amp), label=country))+
  geom_point(col='skyblue')+
  ggrepel::geom_label_repel(label.size=NA, fill='transparent')+ # avoid overlap; no border
  scale_x_continuous(breaks=seq(0,24,6), limits=c(0,24), labels=c('0am','6am','12pm','6pm',''))+
  xlab('Peak time (24-hour clock)')+
  ylab('Probability ratio')+
  scale_y_continuous(limits=c(1, NA))+ # start at 1
  theme_bw()+
  theme(text = element_text(size=14))+ # changes size of all text bar labels
  facet_wrap(~panel)
# for journal
jpeg('figures/BarnettFig2.jpg', width=10, height=5, units='in', res=400, quality=100)
print(splot)
invisible(dev.off())
```

## Difference in journal reviews (late nights and early mornings)

The plot below shows the predicted means for each hour of the day for the two journals. This combines the overall estimates for each hour with the smooth sinusoid used to model the differences between the two journals.

```{r sinusoid.journal.outofhours.reviews}
# reconstruct country means ##
oframe = data.frame(hour=0:23, country='Overall', country.num=0, est = bugs.results$median$intercept + bugs.results$median$beta, stringsAsFactors = FALSE)
# now get the journal specific curve
journal.smooth = bugs.results$median$cosine.j*cos(0:23*2*pi/24) +
  bugs.results$median$sine.j*sin(0:23*2*pi/24)
bmj.open.ests = mutate(oframe, journal = 'BMJ Open')
bmj.ests = mutate(oframe, journal = 'BMJ', est = est + journal.smooth)
to.plot = bind_rows(bmj.open.ests, bmj.ests)
ggplot(data=to.plot, aes(x=hour+0.5, y=exp(est), col=factor(journal)))+
  geom_line(size=1.1)+
  scale_x_continuous(breaks=c(0,6,12,18,24), minor_breaks = 0:24)+
  xlab('Hour')+
  ylab('Probability')+
  scale_color_manual(NULL, values = cbPalette[3:4])+
  theme_bw()+
  theme(legend.position = c(0.2,0.8),
        panel.grid.minor.y = element_blank())
```

As the plot shows, there was little difference in the timing of reviews between the two journals. There were slightly more reviews for the BMJ around 6pm.

# Summary plot of reviews and submissions by hour of day

The plot shows the percent of submissions and reviews by hour, split by each journal.

```{r summary.24hour.plot, fig.width=11, fig.height=6}
# get counts, then percents
for.plot = mutate(both, hour = floor(local.hour),
                  type = ifelse(type=='Submission', 'Submissions', type)) %>% # tiny change to label
  group_by(type, journal, hour) %>%
  summarise(count = n()) %>% 
  group_by(type, journal) %>%
  mutate(total = sum(count),
         hour = hour + 0.5, # move points to middle of hour
    perc = 100*count/total) %>%
  ungroup()
# plot
plot = ggplot(data=for.plot, aes(x=hour, y=perc, col=factor(journal)))+
#  geom_rect(xmin=7, xmax=17.99, ymin=-Inf, ymax=Inf, fill=grey(0.9), alpha=0.2, inherit.aes=FALSE)+ # in hours period ; no longer shade in new version
  geom_vline(xintercept = c(6,12,18), col=grey(0.8))+ # home-made grid because of rect
  geom_hline(yintercept = seq(2,10,2), col=grey(0.8))+ # home-made grid because of rect
  geom_point()+
  scale_color_manual(NULL, values=c('dark red','dark blue'))+
  scale_x_continuous(breaks=c(0,6,12,18,24))+
  scale_y_continuous(breaks=c(0,2,4,6,8,10), limits = c(0, NA))+
  geom_line(size=1.01)+
  theme_bw()+
  theme(text = element_text(size=12), # increase text size for BMJ
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank())+
  xlab('Hour of day')+
  ylab('Percent')+
  facet_wrap(~type, scale='free_y')
plot
# for journal
jpeg('figures/BarnettFig1.jpg', width=7.8, height=5.2, units='in', res=400, quality=100)
print(plot)
invisible(dev.off())
```

# Summary plot of country-specific probabilities

```{r include=FALSE}
# average probabilties from process jags (loop through)
to.tile.mean = NULL
for (k in 1:nrow(DIC.best)){
  which.outcome = DIC.best$outcome[k]
  which.data.text = DIC.best$data[k]
  which.data.text.update = paste(which.data.text, '.', which.outcome, sep='')
  which.journal = DIC.best$journal[k]
  type = DIC.best$model[k]
  season = ifelse(DIC.best$season[k] == 'Season', TRUE, FALSE)
  source('99_jags_filename.R') # create filenames for data, chains and results
  load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R on HPC
  # get averages per country
  source('2_plot_intercepts.R')
  to.plot = mutate(to.plot, k=k, outcome = which.outcome, journal = which.journal, data=which.data.text, label = formatC( round(mean, 2), format='f', digits=2))
  to.tile.mean = bind_rows(to.tile.mean, to.plot)
}
# now add the holiday estimates
to.tile.mean.holiday = NULL
k = 0 # restart index for x-axis
for (which.data.text in c('submission','reviewer')){
  for (which.journal in c('BMJ','BMJ Open')){
    k = k + 1 # add index
    jags.filename.results = paste('JAGS.holiday.', which.data.text, '.', which.journal, '.intercept.NoSeason.results.RData', sep='')
    load(paste('Z:/weekend/', jags.filename.results, sep=''))
  # get averages per country
  source('2_plot_intercepts.R')
  to.plot = mutate(to.plot, k=k, outcome = 'holiday', journal = which.journal, data=which.data.text, label = formatC( round(mean, 2), format='f', digits=2))
  to.tile.mean.holiday = bind_rows(to.tile.mean.holiday, to.plot)
  }
}
```

### Summary plot of weekend estimates

```{r tile.plot.means.weekend, fig.width=12, fig.height=10}
# process tile data data
to.plot = filter(to.tile.mean, Count > 100) %>% # remove small counts
  group_by(Country) %>%
  mutate(n = n(), overall = mean(mean)) %>% # mean of mean
  filter(n == 4) %>% # must have all 4 rows
  ungroup() %>%
  dplyr::select(-outcome, -xaxis, -journal, -n, -var)
ordering = group_by(to.plot, Country) %>%# order by high to low
  slice(1) %>% # first row only
  ungroup() %>%
  arrange(overall) %>% # arrange by overall median
  mutate(rank = 1:n()) %>% 
  dplyr::select(Country, rank) %>%
  mutate(xaxis = factor(rank, labels=Country))
to.plot = left_join(to.plot, ordering, by='Country')
# x-axis labels
j.labels = dplyr::select(to.tile.mean, k, journal) %>% unique() 
j.labels = j.labels$journal
# plot
tile.weekend = ggplot(data=to.plot, aes(x=xaxis, y=k, fill=mean, label=label))+
  geom_tile()+
  geom_text(size=5)+
  xlab('')+
  ylab('')+
  scale_y_continuous(breaks=1:4, labels=j.labels, expand = c(0,0))+
  scale_fill_gradient2('Probability', low = 'dark blue', mid = 'white', high='dark red', midpoint = 0.15, breaks=c(0.10, 0.15, 0.20))+
  g.theme+
  coord_flip(clip = 'off')+
  theme(text = element_text(size=14),
        legend.text = element_text(size=16),
        axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=17),
        plot.margin=unit(c(0.9,0,1.2,0),"cm")) + # increase margin = top, then right, bottom and left
  # axis label outside the plot
  geom_text(y=1.5, x=-0.5, label='Submissions', size=6, fontface='plain')+
  geom_text(y=3.5, x=-0.5, label='Reviews', size=6, fontface='plain')
tile.weekend
```

The numbers in the plot are the mean probabilities of submitting on weekends.

The rows in the plot are ordered using the average probability across the four columns.

### Summary plot of holiday estimates

```{r tile.plot.means.holiday, fig.width=12, fig.height=10}
# process tile data data
to.plot = filter(to.tile.mean.holiday, Count > 100) %>% # remove small counts
  group_by(Country) %>%
  mutate(n = n(), overall = mean(mean)) %>% # mean of mean
  filter(n == 4) %>% # must have all 4 rows
  ungroup() %>%
  dplyr::select(-outcome, -xaxis, -journal, -n, -var)
ordering = group_by(to.plot, Country) %>%# order by high to low
  slice(1) %>% # first row only
  ungroup() %>%
  arrange(overall) %>% # arrange by overall median
  mutate(rank = 1:n()) %>% 
  dplyr::select(Country, rank) %>%
  mutate(xaxis = factor(rank, labels=Country))
to.plot = left_join(to.plot, ordering, by='Country')
# x-axis labels
j.labels = dplyr::select(to.tile.mean, k, journal) %>% unique() 
j.labels = j.labels$journal
# plot
tile.holiday = ggplot(data=to.plot, aes(x=xaxis, y=k, fill=mean, label=label))+
  geom_tile()+
  geom_text(size=5)+
  xlab('')+
  ylab('')+
  scale_y_continuous(breaks=1:4, labels=j.labels, expand = c(0,0))+
  scale_fill_gradient2('Probability', low = 'dark blue', mid = 'white', high='dark red', midpoint = 0.10, breaks=c(0.05, 0.10, 0.15, 0.20))+
  g.theme+
  coord_flip(clip = 'off')+
  theme(text = element_text(size=14),
        legend.text = element_text(size=16),
        axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=17),
        plot.margin=unit(c(0.9,0,1.2,0),"cm")) + # increase margin = top, then right, bottom and left
  # axis label outside the plot
  geom_text(y=1.5, x=-0.5, label='Submissions', size=6, fontface='plain')+
  geom_text(y=3.5, x=-0.5, label='Reviews', size=6, fontface='plain')
tile.holiday
```


The numbers in the plot are the mean probabilities of submitting on holidays relative to other days in the same week.

The rows in the plot are ordered using the average probability across the four columns.

```{r export.tile.plot, include=FALSE}
# add title
tile.weekend = tile.weekend + ggtitle("Weekends")
tile.holiday = tile.holiday + ggtitle("Holidays")
# export
jpeg('figures/BarnettFig4.jpg', width=12, height=10, units='in', res=400, quality = 100) # bigger size for BMJ
grid.arrange(tile.weekend, tile.holiday, ncol=2)
invisible(dev.off())
```

# Summary plot of country-specific probability ranks

```{r include=FALSE}
# get ranks and averages from process jags (loop through)
to.tile = to.mean.plot = table.time = NULL
for (k in 1:nrow(DIC.best)){
  which.outcome = DIC.best$outcome[k]
  which.data.text = DIC.best$data[k]
  which.data.text.update = paste(which.data.text, '.', which.outcome, sep='')
  which.journal = DIC.best$journal[k]
  type = DIC.best$model[k]
  season = ifelse(DIC.best$season[k] == 'Season', TRUE, FALSE)
  source('99_jags_filename.R') # create filenames for data, chains and results
  load(paste('Z:/weekend/', jags.filename.results, sep='')) # from process.jags.R on HPC
  # store changes over time for later table
  this.time = filter(ests, var %in% c('diff','ratio')) %>%
    mutate(outcome = which.outcome, journal = which.journal, data=which.data.text)
  table.time = bind_rows(table.time, this.time)
  # get ranks for tile plot
  ranks = mutate(ranks, k=k, outcome = which.outcome, journal = which.journal, data=which.data.text)
  to.tile = bind_rows(to.tile, ranks)
  # get averages for mean plot
  averages = filter(ests, var=='p', num==2) %>% # average probability in year 2
    mutate(k=k, outcome = which.outcome, journal = which.journal, data=which.data.text)
  to.mean.plot = bind_rows(to.mean.plot, averages)
}
# now add the holiday estimates
for (which.data.text in c('submission','reviewer')){
  for (which.journal in c('BMJ','BMJ Open')){
    k = k + 1 # add index
    jags.filename.results = paste('JAGS.holiday.', which.data.text, '.', which.journal, '.intercept.NoSeason.results.RData', sep='')
    load(paste('Z:/weekend/', jags.filename.results, sep=''))
  # store changes over time for later table
  this.time = filter(ests, var %in% c('diff','ratio')) %>% # difference or ratio
    mutate(outcome = 'holiday', journal = which.journal, data=which.data.text)
  table.time = bind_rows(table.time, this.time)
  # get ranks for tile plot
    which.data.text.convert = ifelse(which.data.text=='Submission', 'submissions', 'reviews') # tiny edit
  ranks = mutate(ranks, k=k, outcome = 'holiday', journal = which.journal, data=which.data.text.convert)
  to.tile = bind_rows(to.tile, ranks)
    # get averages for mean plot 
  averages = filter(ests, var=='overall') %>%
    mutate(mean = inv.logit(mean),
           lower = inv.logit(lower),
           upper = inv.logit(upper), 
           k=k, outcome = 'holiday', journal = which.journal, data=which.data.text)
  to.mean.plot = bind_rows(to.mean.plot, averages)

  }
}
```

The plot below summarises the twelve models using the countries' estimated probabilities. It shows each country's relative rank with 0 (blue) meaning they were the lowest ranked country, 1 (red) the highest, and 0.5 (white) in the middle. We do not show countries with small numbers. The countries are ordered based on their average probability. The plot only shows the mean rank and not the variability in rank.

```{r tile.plot.ranks, fig.width=12, fig.height=10}
# process tile data data
to.plot = filter(to.tile, Count > 100) %>% # remove small counts
  group_by(Country) %>%
  mutate(n = n(), overall = mean(median)) %>% # mean of median
  filter(n == 8) %>% # must have all 8 rows
  ungroup() %>%
  dplyr::select(-outcome, -journal, -n)
ordering = group_by(to.plot, Country) %>%# order by high to low
  slice(1) %>% # first row only
  ungroup() %>%
  arrange(overall) %>% # arrange by overall median
  mutate(rank = 1:n()) %>% 
  dplyr::select(Country, rank) %>%
  mutate(xaxis = factor(rank, labels=Country))
# x-axis labels
j.labels = dplyr::select(to.tile, k, journal) %>% unique() 
j.labels = j.labels$journal
to.plot = left_join(to.plot, ordering, by='Country')
# add specific missing row for Ireland so that it shows in green - no longer needed
add = filter(to.plot, Country=='Ireland', k==1) %>% # build on current data because its easier
  mutate(k=11, median=NA)
to.plot = bind_rows(add, to.plot)
# plot
tile = ggplot(data=to.plot, aes(x=xaxis, y=k, fill=median))+
  geom_tile()+
  xlab('')+
  ylab('')+
  scale_y_continuous(breaks=1:8, labels=j.labels, expand = c(0,0))+
  scale_fill_gradient2('Rank', low = 'dark blue', mid = 'white', high='dark red', na.value='light green', midpoint = 0.5, breaks=c(0.03, 0.5, 1), labels=c('Lowest','Median','Highest'))+
  g.theme+
  coord_flip(clip = 'off')+
  theme(text = element_text(size=14),
        legend.text = element_text(size=16),
        axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=17),
    plot.margin=unit(c(0.9,0,1.2,0),"cm")) + # increase margin = top, then right, bottom and left
  # add vertical lines
  geom_hline(yintercept = c(4.5,8.5)) + # Add vertical lines to tile plot to split holidays and weekends
  # axis label outside the plot
  geom_text(y=1.5, x=-0.5, label='Submissions', size=6, fontface='plain')+
  geom_text(y=3.5, x=-0.5, label='Reviews', size=6, fontface='plain')+
  geom_text(y=5.5, x=-0.5, label='Submissions', size=6, fontface='plain')+
  geom_text(y=7.5, x=-0.5, label='Reviews', size=6, fontface='plain')+
  #
  geom_text(y=2.5, x=-1, label='Weekends', size=6, fontface='plain')+
  geom_text(y=6.5, x=-1, label='Holidays', size=6, fontface='plain')+
  # repeat at top
  geom_text(y=2.5, x=17, label='Weekends', size=6, fontface='plain')+
  geom_text(y=6.5, x=17, label='Holidays', size=6, fontface='plain')
tile
```

China often had the highest probability of any country for submissions and reviews, but were on or below the median rank on holidays. 
Japan also had relatively high probabilities.

Three Scandinavian countries (Norway, Finland and Sweden) had some of the lowest probabilities. Denmark was also relatively low.

Three mediterranean countries (Spain, Italy and France) have relatively high probabilties. Many workplaces in Spain have a siesta during the day and working in the evenings is relatively normal.

# Summary plot of overall probabilities, means and 95% credible intervals

The plot below shows the overall probabilities of reviews and submissions on weekends and holidays. These are the overall averages across all countries together with the 95% credible intervals.

```{r mean.summary, fig.width=6, fig.height=4.5}
to.mean.plot.final = mutate(to.mean.plot,
            data = ifelse(data %in% c('reviews','reviewer','Reviews'), 'Reviews', 'Submissions'),
            x = as.numeric(journal=='BMJ Open') + as.numeric(data=='Reviews')/5, # x-axis with jitter
            outcomen = 1,
            outcomen = ifelse(outcome=='holiday', 2, outcomen),
            panel = factor(outcomen, levels=1:2, labels=c('Weekend','Holiday')))
summary.plot = ggplot(data=to.mean.plot.final, aes(x=x, y=mean, 
      ymin=lower, ymax=upper, col=factor(data)))+
  geom_point(size=4)+
  geom_errorbar(width=0, size=1.1)+
  scale_color_manual(NULL, values=cbPalette[3:5])+
  scale_x_continuous(breaks=c(0,1), limits=c(-0.4, 1.4), labels=c('BMJ','BMJ Open'))+
#  scale_shape_manual(NULL, values=c(15,16))+
  theme_bw()+
  theme(panel.grid.minor.x = element_blank())+
  xlab('')+
  ylab('Probability')+
  facet_wrap(~panel)+
  theme()
summary.plot
```

There was a higher probability of reviews on the weekend compared with submissions. 

The were no big differences between the two journals. 

## Table of overall probabilities

The table below shows the same information as the previous plot (CI = 95% credible interval).

```{r summary.table}
to.table = mutate(to.mean.plot.final) %>%
  rename(Mean = mean, Journal = journal, Outcome=outcome, Type=data) %>%
  mutate(CI = paste(round(lower*100)/100, ' to ', round(upper*100)/100, sep='')) %>%
  dplyr::select(Outcome, Type, Journal, Mean, CI)
pander(to.table, digits=2, style='simple')
```

## Summary table of changes over time

This table summarises the changes over time.

### Probability ratios

```{r summary.table.time}
to.table = mutate(table.time, 
        data = ifelse(data=='submissions', 'Submission', data),
        data = ifelse(data=='reviews', 'Reviews', data),
        mean = round(mean*100)/100,
        lower = round(lower*100)/100,
        upper = round(upper*100)/100,
        CI = paste(sprintf(lower, fmt='%4.2f'), ', ', sprintf(upper, fmt='%4.2f'), sep=''),
        res = paste(sprintf(mean, fmt='%4.2f'), ' (', CI, ')', sep='') ) %>%
  dplyr::select(outcome, journal, data, var, res) %>%
  rename(`Mean CI` = res) %>%
  filter(var=='ratio') %>% dplyr::select(-var) # Just ratio
pander(to.table, style='simple')
```

### Probability differences (absolute)

```{r summary.table.time.absolute}
to.table = mutate(table.time, 
        data = ifelse(data=='submissions', 'Submission', data),
        data = ifelse(data=='reviews', 'Reviews', data),
        mean = round(mean*1000)/1000,
        lower = round(lower*1000)/1000,
        upper = round(upper*1000)/1000,
        CI = paste(sprintf(lower, fmt='%4.3f'), ', ', sprintf(upper, fmt='%4.3f'), sep=''),
        res = paste(sprintf(mean, fmt='%4.3f'), ' (', CI, ')', sep='') ) %>%
  dplyr::select(outcome, journal, data, var, res) %>%
  rename(`Mean CI` = res) %>%
  filter(var=='diff') %>% dplyr::select(-var) # Just difference
pander(to.table, style='simple')
```

### Probability differences (absolute percents)

This is the same table as above, but on a percentage scale.

```{r summary.table.time.absolute.percent}
to.table = mutate(table.time, 
        data = ifelse(data=='submissions', 'Submission', data),
        data = ifelse(data=='reviews', 'Reviews', data),
        mean = round(mean*1000)/10,
        lower = round(lower*1000)/10,
        upper = round(upper*1000)/10,
        CI = paste(sprintf(lower, fmt='%3.1f'), ', ', sprintf(upper, fmt='%3.1f'), sep=''),
        res = paste(sprintf(mean, fmt='%3.1f'), ' (', CI, ')', sep='') ) %>%
  dplyr::select(outcome, journal, data, var, res) %>%
  rename(`Mean CI` = res) %>%
  filter(var=='diff') %>% dplyr::select(-var) # Just difference
pander(to.table, style='simple')
```
